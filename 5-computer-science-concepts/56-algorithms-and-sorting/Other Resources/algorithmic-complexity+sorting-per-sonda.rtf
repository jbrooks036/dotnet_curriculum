{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Georgia;}{\f1\fnil\fcharset0 Arial;}{\f2\fnil\fcharset0 Nova Mono;}{\f3\fnil\fcharset1 Cambria Math;}{\f4\fnil Cambria Math;}}
{\colortbl ;\red0\green0\blue0;\red0\green0\blue255;}
{\*\generator Riched20 6.3.9600}{\*\mmathPr\mmathFont3\mwrapIndent1440 }\viewkind4\uc1 
\pard\sl276\slmult1\cf1\b\f0\fs28\lang9  \b0\f1\fs22\par
\b\f0\fs28 Algorithmic Complexity and Sorting  (from Sonda's Notes)\par
\b0\f1\fs22\par
\f0 The slow implementation is to have each query check every cell to see if it meets that criteria. This is called 0(n), Big O notation. This is still faster than 0(log n), which is an even slower function graphically). Faster than both are the 0(n squared) which is creating nested while loops \f1\par
\par
\f0 To avoid visiting every single node when making a query, you can make your structure into a tree such as a hash table and go through ever smaller categories. Binary trees insert in a specific way and they have a root with two branches that compare two decisions. You can also go through a binary tree by breadth-first search or depth-first search.\f1\par
\par
\f0 recursive function is a function that calls itself. Instead of simply returning a calculation, the calculation points to a duplicate of itself going through the calculation as many times as it needs.  For example, the Fibonacci sequence with f(n+1) + f(n-1) in which the arguments are very similar to itself or factorials n!\f1\par
\par
\f0 The same thing can be said with branches of a tree. Each decision of a tree is basically performing the same operation as the one before it in order to decide where to go next. The base step is the last step where it stops calling itself. The entire function will go through all its child functions and once all of them gets completed, then it will provide you the answer.\f1\par
\par
\f0 Selection Sort:\f1\par
\f0 Example: 8, 17, 4, 2, 11, 6\f1\par
\f0 -selects the first item, compares it with the rest and finds the smallest value it can compare to and it switches the item. So starts with 8, then it goes through the whole list and sees that 2 is the smallest and switches the two number places. Then list becomes 2, 17, 4, 8, 11, 6, thus 2 is started. Then it does this again finding the next smallest is 4 in the whole list and reorders. So now it\rquote s 2, 4, 17, 8, 11, 6. So with 6, then it would be 2, 4, 6, 8, 11, 17.\f1\par
\par
\f0 Merge Sort:\f1\par
\f0 Example:  8, 17, 4, 2, 11, 6\f1\par
\f0 -You split the list and sort them separately. And then you merge them together when you're done with the pieces.??\f1\par
\f0 -First, you draw an imaginary line through the center so you have two lists 8,17,4 and 2,11,6. -Now, slice it again, so 8 and 17, 4 AND 2 and 11,6. \f1\par
\f0 -Now sorting becomes pretty trivial. For example, 8 will just be 8. Between 17 and 4, 4 comes before 17. So altogether you have 8 AND 4,17 AND 2 AND 6,11.\f1\par
\f0 -Then you compare chunks with each other. Between 8 and 4, 4 is first. So the first merged chunk will be 4, 8,17.  Then for the second merged chunk you compare 2 with 6,11 to become 2, 6, 11. \f1\par
\f0 -Then compare 17 with the whole second chunk to become 2,6,11,17 to merge.\f1\par
\f0 -Then compare 8 with the whole second chunk to become 2, 6, 8, 11, 17 to merge.\f1\par
\f0 -Then compare 4 with the whole second chunk to become 2, 4, 6, 8, 11, 17.  The end.\f1\par
\par
\f0 These recursive functions all happens simultaneously.\f1\par
\par
\f2\tab\f3\u8594?\f2  Resource:  {\cf0\f0{\field{\*\fldinst{HYPERLINK https://www.youtube.com/watch?v=EeQ8pwjQxTM }}{\fldrslt{https://www.youtube.com/watch?v=EeQ8pwjQxTM\ul0\cf0}}}}\cf0\f0\fs22\par
\cf1\f1\par
\par
\lang9\par
\b\f0\fs24 JASON ORENDORFF!!!! at the Library\b0\f1\fs22\par
{\cf0\f0\fs24{\field{\*\fldinst{HYPERLINK https://jorendorff.github.io/hackday/2012/library/ }}{\fldrslt{https://jorendorff.github.io/hackday/2012/library/\ul0\cf0}}}}\f0\fs24  \f1\fs22\par
\f0\fs24 algorithm - plan for how to solve a problem\f1\fs22\par
\f0\fs24 data structure - the shape of the data in your program. For example, linked lists, tree, array, dictionary, document. With an array its memory efficient but its harder to move the data. Linked lists are easy to move things around.\f1\fs22\par
\f0\fs24 -within a sorted array, you can do less than or greater than to do a binary search where you randomly pick a book, see if it is greater than or less than the dewey number, and then throw out the half that would not contain this book. And then do it again, and again, until you find your book. A binary search is optimal for sorted array.\f1\fs22\par
\f0\fs24 -For SQL servers, what is slowest is unloading the disk, such as the walking part in a library. So SQL has the equivalent of signs (index) so that it doesn\rquote t have to open each table (go to each shelf). \f1\fs22\par
\f0\fs24 -Insertion sort is the fastest for small arrays. For big arrays, it would be time-consuming to do binary search for each book and it\rquote s consuming to move all the books or bytes over to make room.\f1\fs22\par
\f0\fs24 -Bucket sort is better for big arrays. There are large sections or buckets where they are presorted by larger categories. And then bucket sort again to sort the individual categories. So keep doing bucket sort until they are small enough to do insertion sort.\f1\fs22\par
\f0\fs24 -For largish arrays, they can also use merge sort. You half and half and half the array until you can do insertion sort, then you merge two arrays together again and again until it is sorted. Problem is with gigantic arrays you will have to have three arrays to keep in memory, the two arrays you want to merge and the merged array. So you can do quick sort.\f1\fs22\par
\f0\fs24 -Quick sort is kind of like merge sort, but in the beginning the method takes three random points out of the array and picks the one in the middle, hoping it\rquote s representative of the middle of the whole array. \f1\fs22\par
\f3\fs24\u8594?\f2  Link to his 2001 Obfuscated C winning entry:  {\cf0\f0{\field{\*\fldinst{HYPERLINK http://www.ioccc.org/2001/jason.c }}{\fldrslt{http://www.ioccc.org/2001/jason.c\ul0\cf0}}}}\f0\fs24 . Extra points if you know what this program actually does.\f1\fs22\par
\lang9\par
\par
\b\f0 Linked Lists:\b0\f1\par
\f0 arrays - predefined, homogenous, with a fixed length and size.\f1\par
\f0 -when an array gets created, it uses a chunk of memory to know the address of each value.\f1\par
\f0 array lists - dynamically allocated, homogenous values. Under the hood, a list is actually an array. Say we add 10 items to the list using list.Add(). When we add the 11th item, there is no more space in this array. It creates a new array and increase the size of the array by a percentage depending on what you plan to put there. Then, it copies each item from the old array in the beginning, puts it into the new one, along with the 11th item. \f1\par
\f0 -in a single linked lists, you can go through a list to the next item. You can only go forward to go through a list.\f1\par
\f0 -in order to delete an item you can make that node point to a different thing, thus deleting the value that doesn\rquote t have anything pointed to it.\f1\par
\f0 -in a double linked lists, you have a list that point to the next item using .Next() with a reference to your last node. In addition, you have a reference that also points to the item previous to it. This enables you to go forward AND backwards. \f1\par
\f0 -Changing, modifying, adding and deleting is much cheaper in a linked list as opposed to an array, since in an array, if something gets deleted, each item will need to be shifted.\f1\par
\par
\par
\b\f0 Algorithm Complexity: Making Databases Fast\b0\f1\par
{\cf0\f0{\field{\*\fldinst{HYPERLINK https://github.com/elizabrock/software-development-curriculum/blob/master/computer-science/algorithms/introduction-to-algorithmic-complexity.md }}{\fldrslt{https://github.com/elizabrock/software-development-curriculum/blob/master/computer-science/algorithms/introduction-to-algorithmic-complexity.md\ul0\cf0}}}}\f0\fs22  \f1\par
\f0 -Big-O are general algorithm in which the thing that you are limited by and that you want to constrain yourself to when you are creating a database structure.\f1\par
\f0 -Sometimes, you have very efficient algorithm that makes a huge data structure that takes time at first, but then becomes super fast. Or you have an algorithm that doesn\rquote t take up much memory, but is rather slow. The size and composition of data also affects what algorithm you want.\f1\par
\f0 -In order to determine which class of algorithm that you are using, you look at how they behave in terms of the amount of input that is given (n) and then simplify it down to make the comparison. We use specifics to determine which general algorithm to use.\f1\par
\par
\b\f0 Stacks and Queues:\b0\f1\par
\f2 -a stack is a last in, first out data structure, like a stack of plates. Stacks are secretly singly-linked lists. So when adding, just a new node as 0(1) as opposed to an array in which you add to first node, everything else must move over 0(n) \f3\u8592?\f2  less efficient. In stacks and queues, its very good at push and pop where you change the first or last node, but you can\f4\rquote\f2 t access what\f4\rquote\f2 s in the middle.\f1\lang9\par
\par
\b\f0 Numbers:\b0\f1\par
\b\f0 base 10\b0\f1\par
\b\f0 base 2 is binary\b0  1 + 1 = 10 which is 2\f1\par
\b\f0 base 8 is octal \b0 7 + 1 = 0x10\f1\par
\b\f0 base 16 is hexadecimal \b0  \f1\par
\f2 -Ruby the interpreter \f3\u8594?\f2  C and compiles \f3\u8594?\f2  Assembly which is almost limited english that talks to hardware \f3\u8594?\f2  hardware.\f1\par
\f0\lang9 -registers are memory cells and assembly is used to give commands telling how and what things are stored in them. In assembly, you tell values where to go in memory and what exactly to do.\f1\par
\f0 -If we were writing C, it compiles down into assembly particular to which hardware that you have in order to run your code.\f1\par
\f0 -That is why in C Sharp, you have fixed lengths. It knows exactly where you stored them, so it can go through it really fast. \f1\par
\par
\par
\par

\pard\sl276\slmult1\qc\par
\b\f0\fs24\par
}
 